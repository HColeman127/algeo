<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Procedural macros to help with overloading operators."><meta name="keywords" content="rust, rustlang, rust-lang, xops"><title>xops - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../xops/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate xops</p><div class="block version"><p>Version 0.1.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all xops's items</p></a><p class="location"></p><div id="sidebar-vars" data-name="xops" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">xops</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/xops/lib.rs.html#1-129" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Procedural macros to help with overloading operators.</p>
<h1 id="about" class="section-header"><a href="#about">About</a></h1>
<p>xops = e<strong>X</strong>(tra/tended/cellent) + <strong>OP</strong>erat(or/ion) + <strong>S</strong></p>
<p>This crate provides macros which implement families of operations related to a given operation implementation. </p>
<h1 id="usageexamples" class="section-header"><a href="#usageexamples">Usage/Examples</a></h1>
<p>See <a href="attr.binop.html" title="binop"><code>binop</code></a></p>
<h1 id="operator-overloading-basics" class="section-header"><a href="#operator-overloading-basics">Operator Overloading Basics</a></h1>
<p>All the traits for overloading operators in <a href="https://doc.rust-lang.org/nightly/core/ops/index.html" title="std::ops"><code>std::ops</code></a> follow a common pattern. Take, for example, the <code>Add</code> trait for overloading the <code>+</code> operator; its trait definition looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">trait</span> <span class="ident">Add</span><span class="op">&lt;</span><span class="ident">Rhs</span> <span class="op">=</span> <span class="self">Self</span><span class="op">&gt;</span> {
    <span class="kw">type</span> <span class="ident">Output</span>;
    <span class="kw">fn</span> <span class="ident">add</span>(<span class="self">self</span>, <span class="ident">rhs</span>: <span class="ident">Rhs</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span><span class="ident">::Output</span>;
}</pre></div>
<p>The receiving type <code>Self</code> is the left-hand side of the <code>+</code> operator and the generic type argument <code>Rhs</code> is right-hand side. Implementing <code>Add&lt;B&gt;</code> for <code>A</code> will then make the expression <code>a + b</code> equivalent to <code>&lt;A as Add&lt;B&gt;&gt;::add(a, b)</code> , for any <code>a: A</code> and <code>b: B</code>.</p>
<p>For examples of implementations of these traits, see <a href="https://doc.rust-lang.org/nightly/core/ops/index.html" title="std::ops"><code>std::ops</code></a>.</p>
<h1 id="discussion" class="section-header"><a href="#discussion">Discussion</a></h1>
<p>The functionality of xops is very much like other ‘derive’ crates, automatically deriving trait implementations. However, instead of the attributes being placed on a struct, enum, or union (as with the <code>derive</code> attribute), the attributes in xops are placed on <em>trait implementations</em>, i.e., items of the form <code>impl Trait for Type { ... }</code>. </p>
<p>The reasoning behind putting the attributes on trait implementations has both pragmatic and semantic components:</p>
<ul>
<li>
<p>From a trait implementation, xops is able to directly parse all of the information it needs to do its job, namely type, trait, and method identifiers. If xops used derive macros, all this information would either need to be given by the user or xops would need some sort of catalogue about all the standard library operations. With the current approach, however, you are not even limited to just the standard library operations, xops will work on any traits with the same sort of layout. (Although, Rust does not support custom operation overloading, so there probably isn’t much use outside the standard library operations).</p>
</li>
<li>
<p>In Rust, when we implement <code>Add&lt;B&gt;</code> for <code>A</code>, we are essentially saying <em><code>A</code> is capable of addition with <code>B</code></em>, and this is subtlety distinct from <em><code>B</code> is capable of addition with <code>A</code></em>, which we would achieve by implementing <code>Add&lt;A&gt;</code> for <code>B</code>. In mathematics, on the other hand, it would be more common to say something like <em>addition is defined between <code>A</code> and <code>B</code></em>; the difference being that the operation itself is treated as more of a first-class citizen. The approach of xops is in agreement with the latter interpretation, to the extent that Rust permits.</p>
</li>
</ul>
</div><h2 id="attributes" class="section-header"><a href="#attributes">Attribute Macros</a></h2>
<table><tr class="module-item"><td><a class="attr" href="attr.binop.html" title="xops::binop attr">binop</a></td><td class="docblock-short"><p>For deriving extra implementations of a binary operation.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="xops" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script></body></html>